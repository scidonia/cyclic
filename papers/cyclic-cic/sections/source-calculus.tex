\section{Source calculus (terms, typing, semantics)}
\label{sec:source}

This section summarizes the \emph{source} term language and its typing and operational semantics.
It corresponds closely to:
\begin{itemize}
\item term syntax: \texttt{theories/Syntax/Term.v}
\item typing: \texttt{theories/Judgement/Typing.v} (inductive judgement \texttt{has\_type})
\item call-by-name semantics: \texttt{theories/Semantics/Cbn.v}
\end{itemize}

\subsection{Term syntax}

We write terms \(t,u\) and types \(A,B\) using the following constructors (de Bruijn indices for variables):
\[
\begin{array}{rcl}
 t &::=& \Var{x}
 \mid \Sort{i}
 \mid \PiTy{A}{B}
 \mid \Lam{A}{t}
 \mid \App{t}{u}
 \mid \Fix{A}{t}
 \\
 &&\mid \Ind{I}
 \mid \Roll{I}{c}{\overline{p}}{\overline{r}}
 \mid \Case{I}{t}{C}{\overline{\mathit{br}}}
\end{array}
\]

\subsection{Typing}

A typing environment \(\env\) stores inductive signatures (strictly-positive definitions).
A context \(\ctx\) is a list of types.
The main judgement is \(\hastype{\env}{\ctx}{t}{A}\).

Below is the core typing system (informally mirroring \texttt{Typing.has\_type}).
We omit the full inductive signature side-conditions and arity bookkeeping, but include the essential shape.

\begin{Rules}
  \Infer{TyVar}{\ctx(x)=A}{\hastype{\env}{\ctx}{\Var{x}}{A}}\\
  \Infer{TySort}{}{\hastype{\env}{\ctx}{\Sort{i}}{\Sort{i+1}}}\\
  \Infer{TyPi}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
              \hastype{\env}{A::\ctx}{B}{\Sort{j}}}
            {\hastype{\env}{\ctx}{\PiTy{A}{B}}{\Sort{\max(i,j)}}}\\
  \Infer{TyLam}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
               \hastype{\env}{A::\ctx}{t}{B}}
            {\hastype{\env}{\ctx}{\Lam{A}{t}}{\PiTy{A}{B}}}\\
  \Infer{TyApp}{\hastype{\env}{\ctx}{t}{\PiTy{A}{B}}\\
               \hastype{\env}{\ctx}{u}{A}}
            {\hastype{\env}{\ctx}{\App{t}{u}}{B[u/0]}}\\
  \Infer{TyFix}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
               \hastype{\env}{A::\ctx}{t}{A\uparrow}}
            {\hastype{\env}{\ctx}{\Fix{A}{t}}{A}}
\end{Rules}

\paragraph{Inductives, constructors, and case.}
The development includes strictly-positive inductives \(\Ind{I}\), constructor values \(\Roll{I}{c}{\overline{p}}{\overline{r}}\), and elimination by \(\Case{I}{t}{C}{\overline{\mathit{br}}}\).
Typing is guided by an inductive signature lookup (see \texttt{StrictPos.v} and \texttt{Typing.v}).
Branches are typed by building an iterated Pi-type over the constructor arguments.

\subsection{Call-by-name operational semantics}

We use a weak-head, call-by-name reduction relation \(t \step u\) (see \texttt{Semantics/Cbn.v}).
Key rules include:

\begin{Rules}
  \Infer{Step-Beta}{}{\App{(\Lam{A}{t})}{u} \step t[u/0]}\\
  \Infer{Step-App1}{t \step t'}{\App{t}{u} \step \App{t'}{u}}\\
  \Infer{Step-Fix}{}{\Fix{A}{t} \step t[\Fix{A}{t}/0]}\\
  \Infer{Step-CaseScrut}{t \step t'}{\Case{I}{t}{C}{\overline{\mathit{br}}} \step \Case{I}{t'}{C}{\overline{\mathit{br}}}}\\
  \Infer{Step-CaseRoll}{\mathit{branch}(\overline{\mathit{br}},c)=\mathit{br}}
                     {\Case{I}{(\Roll{I}{c}{\overline{p}}{\overline{r}})}{C}{\overline{\mathit{br}}} \step \mathit{br}\; (\overline{p} \mathbin{++} \overline{r})}
\end{Rules}

We write \(t \steps u\) for the reflexive-transitive closure of \(\step\).
Values are \(\lambda\)-abstractions and constructor rolls.
