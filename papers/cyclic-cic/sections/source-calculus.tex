\section{Source calculus (terms, typing, semantics)}
\label{sec:source}

This section summarizes the \emph{source} term language and its typing and operational semantics.
It corresponds closely to:
\begin{itemize}
\item term syntax: \texttt{theories/Syntax/Term.v}
\item typing: \texttt{theories/Judgement/Typing.v} (inductive judgement \texttt{has\_type})
\item call-by-name semantics: \texttt{theories/Semantics/Cbn.v}
\end{itemize}

\subsection{Term syntax}

We write terms \(t,u\) and types \(A,B\) using the following constructors (de Bruijn indices for variables):
\[
\begin{array}{rcl}
 t &::=& \Var{x}
 \mid \Sort{i}
 \mid \PiTy{A}{B}
 \mid \Lam{A}{t}
 \mid \App{t}{u}
 \mid \Fix{A}{t}
 \\
 &&\mid \Ind{I}{\overline{a}}
 \mid \Roll{I}{c}{\overline{a}}
 \mid \Case{I}{t}{C}{\overline{\mathit{br}}}
\end{array}
\]

\paragraph{Indexed inductive families.}
The system supports CIC-style indexed inductive families.
An inductive \(\Ind{I}{\overline{a}}\) is applied to arguments \(\overline{a}\) (parameters and indices).
Constructors \(\Roll{I}{c}{\overline{a}}\) take all arguments (non-recursive and recursive) uniformly as \(\overline{a}\).
The dependent case eliminator \(\Case{I}{t}{C}{\overline{\mathit{br}}}\) has a \emph{dependent motive} \(C\) binding the scrutinee: under the binder, \(C\) has access to \(x : \Ind{I}{\overline{\mathit{idx}}}\) where \(\overline{\mathit{idx}}\) are the scrutinee's indices.

\subsection{Typing}

A typing environment \(\env\) stores inductive signatures (strictly-positive definitions).
A context \(\ctx\) is a list of types.
The main judgement is \(\hastype{\env}{\ctx}{t}{A}\).

Below is the core typing system (informally mirroring \texttt{Typing.has\_type}).
We omit the full inductive signature side-conditions and arity bookkeeping, but include the essential shape.

\begin{Rules}
  \Infer{TyVar}{\ctx(x)=A}{\hastype{\env}{\ctx}{\Var{x}}{A}}\\
  \Infer{TySort}{}{\hastype{\env}{\ctx}{\Sort{i}}{\Sort{i+1}}}\\
  \Infer{TyPi}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
              \hastype{\env}{A::\ctx}{B}{\Sort{j}}}
            {\hastype{\env}{\ctx}{\PiTy{A}{B}}{\Sort{\max(i,j)}}}\\
  \Infer{TyLam}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
               \hastype{\env}{A::\ctx}{t}{B}}
            {\hastype{\env}{\ctx}{\Lam{A}{t}}{\PiTy{A}{B}}}\\
  \Infer{TyApp}{\hastype{\env}{\ctx}{t}{\PiTy{A}{B}}\\
               \hastype{\env}{\ctx}{u}{A}}
            {\hastype{\env}{\ctx}{\App{t}{u}}{B[u/0]}}\\
  \Infer{TyFix}{\hastype{\env}{\ctx}{A}{\Sort{i}}\\
               \hastype{\env}{A::\ctx}{t}{A\uparrow}}
            {\hastype{\env}{\ctx}{\Fix{A}{t}}{A}}
\end{Rules}

\paragraph{Typing indexed inductives.}
Let \(\Sigma(I) = (\overline{P}, \overline{X}, \ell, \overline{\mathit{ctor}})\) where:
\begin{itemize}
\item \(\overline{P}\) are uniform parameters
\item \(\overline{X}\) are index types
\item \(\ell\) is the universe level
\item \(\overline{\mathit{ctor}}\) are constructor specifications
\end{itemize}

Each constructor \(c\) has:
\begin{itemize}
\item Non-recursive argument types \(\overline{\tau}_{\mathit{param}}\)
\item Recursive argument specifications (indices at which recursion occurs)
\item Result indices \(\overline{\mathit{idx}}_c\)
\end{itemize}

\textbf{Typing rules (informal)}:
\begin{itemize}
\item \(\Ind{I}{\overline{a}}\) has type \(\Sort{\ell}\) if \(\overline{a}\) matches \(\overline{P} \mathbin{++} \overline{X}\)
\item \(\Roll{I}{c}{\overline{a}}\) has type \(\Ind{I}{(\overline{p} \mathbin{++} \overline{\mathit{idx}}_c[\overline{a}])}\) where \(\overline{p}\) are the parameter values
\item \(\Case{I}{t}{C}{\overline{\mathit{br}}}\):
  \begin{itemize}
  \item Scrutinee: \(\hastype{\env}{\ctx}{t}{\Ind{I}{\overline{\mathit{scrutIdx}}}}\)
  \item Motive: \(\hastype{\env}{\ctx, x:\Ind{I}{\overline{\mathit{scrutIdx}}}}{C}{\Sort{i}}\) (dependent on scrutinee)
  \item Each branch: \(\hastype{\env}{\ctx}{\mathit{br}_c}{\Pi\overline{\tau}_c.\; C[\Roll{I}{c}{\overline{a}}/x]}\)
  \item Result type: \(C[t/x]\)
  \end{itemize}
\end{itemize}

See \texttt{theories/Syntax/StrictPos.v} for the signature representation and \texttt{theories/Judgement/Typing.v} for the full typing rules.

\subsection{Call-by-name operational semantics}

We use a weak-head, call-by-name reduction relation \(t \step u\) (see \texttt{Semantics/Cbn.v}).
Key rules include:

\begin{Rules}
  \Infer{Step-Beta}{}{\App{(\Lam{A}{t})}{u} \step t[u/0]}\\
  \Infer{Step-App1}{t \step t'}{\App{t}{u} \step \App{t'}{u}}\\
  \Infer{Step-Fix}{}{\Fix{A}{t} \step t[\Fix{A}{t}/0]}\\
  \Infer{Step-CaseScrut}{t \step t'}{\Case{I}{t}{C}{\overline{\mathit{br}}} \step \Case{I}{t'}{C}{\overline{\mathit{br}}}}\\
  \Infer{Step-CaseRoll}{\mathit{branch}(\overline{\mathit{br}},c)=\mathit{br}}
                     {\Case{I}{(\Roll{I}{c}{\overline{a}})}{C}{\overline{\mathit{br}}} \step C[\Roll{I}{c}{\overline{a}}/x] \mathbin{\triangleright} (\mathit{br}\; \overline{a})}
\end{Rules}

In the \textsc{Step-CaseRoll} rule, the motive \(C\) is instantiated with the constructor term, then the branch is applied to the constructor arguments.
This combines the dependent elimination (motive instantiation) with the standard case reduction.

We write \(t \steps u\) for the reflexive-transitive closure of \(\step\).
Values are \(\lambda\)-abstractions and constructor rolls.
