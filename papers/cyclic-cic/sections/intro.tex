\section{Introduction}

The design goal of this project is not simply to add ``cycles'' for convenience.
The goal is to change what we treat as \emph{primitive} in a proof calculus.

In conventional systems, recursive reasoning is packaged as a fixed-point operator or as a family of induction/recursion schemata.
Those choices are powerful, but they also hard-code a particular presentation of recursion into the syntax of proofs.
As a result, proofs that are semantically equivalent can remain syntactically far apart, even after many semantics-preserving transformations.

Cyclic proof theory suggests a different decomposition:
\begin{quote}
A proof is a finite graph of locally-correct steps; recursion is represented by cycles; and soundness is ensured by a global progress condition.
\end{quote}

This decomposition has an attractive consequence for proof engineering and normalization:
we can refactor recursive structure (fold/refold), commute conversions, and perform administrative normalization without being forced to preserve the exact boundaries of \texttt{fix} binders or induction schemata.
In the best case, normalization can reveal that two proofs are not just equivalent, but \emph{the same cyclic object} after refolding.

The rest of the paper outlines:
\begin{itemize}
\item the source CIC-like term calculus (Section~\ref{sec:source});
\item the cyclic proof/term graph architecture (Section~\ref{sec:cyclic});
\item the global condition on cycles (Section~\ref{sec:global});
\item and representative transformations like \textsc{CaseCase} and head beta-reduction (Section~\ref{sec:transforms}).
\end{itemize}
