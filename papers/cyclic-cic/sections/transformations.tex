\section{Transformations: \textsc{CaseCase}, head beta, unfold/refold}
\label{sec:transforms}

This section outlines the main transformations currently being developed at the term level, with the intended lift to cyclic proof objects via extraction.
The motivating theme is not merely that these rewrites preserve observational equivalence, but that they support a notion of \emph{canonical cyclic representatives}.

\subsection{Beta-reduction strategies}

The file \texttt{theories/Transform/BetaReduce.v} defines several reduction strategies:

\paragraph{Single-step head reduction.}
\[
\mathsf{beta\_reduce\_once}(t) \triangleq
\begin{cases}
  (\lambda(A).\,\mathit{body})\;u \mapsto \mathit{body}[u/0] &\text{if } t = (\lambda(A).\,\mathit{body})\;u \\
  t &\text{otherwise.}
\end{cases}
\]

\paragraph{Weak-head normal form (WHNF).}
\(\mathsf{whnf\_reduce}(n, t)\) iterates head reductions until reaching WHNF or exhausting fuel \(n\).
This reduces only at the head position, matching call-by-name semantics.

\paragraph{Full normalization.}
\(\mathsf{full\_normalize}(n, t)\) reduces everywhere, including under binders:
\begin{itemize}
\item First reduces to WHNF at the head
\item Then recursively normalizes all subterms
\item Descends under \(\lambda\), \(\Pi\), \texttt{fix}, and case motives
\end{itemize}

The development proves a CIU-style correctness theorem for head reduction:
\[
\hastype{\env}{\ctx}{t}{A} \implies \mathsf{ciu\_jTy}\;\env\;\ctx\;t\;(\mathsf{beta\_reduce\_once}(t))\;A.
\]

\subsection{\textsc{CaseCase}: commuting nested case}

The file \texttt{theories/Transform/CaseCase.v} implements a commuting conversion for nested cases.
Informally:
\[
\Case{J}{(\Case{I}{x}{C}{\overline{\mathit{br}_I}})}{D}{\overline{\mathit{br}_J}}
\quad\leadsto\quad
\Case{I}{x}{C}{\overline{\mathit{br}'_I}}
\]

where each inner branch is transformed to:
\[
\mathit{br}'_I \;\triangleq\; \text{(rebuild a lambda prefix for the constructor arity)}\;\ldots\;\text{then}\;\Case{J}{(\mathit{br}_I\;\overline{a})}{D}{\overline{\mathit{br}_J}}.
\]

In the development, the constructor arity/types are obtained from the inductive signature environment, and the branch transform is implemented by a function \texttt{commute\_branch\_typed\_rec}.

\subsection{Motive propagation}

With dependent case elimination, we can propagate information about the scrutinee into the motive when the scrutinee is known to be a constructor:
\[
\Case{I}{(\Roll{I}{c}{\overline{a}})}{C}{\overline{\mathit{br}}}
\quad\leadsto\quad
\Case{I}{(\Roll{I}{c}{\overline{a}})}{C[\Roll{I}{c}{\overline{a}}/x]}{\overline{\mathit{br}}}
\]

This is semantically a no-op (the substitution happens anyway during case reduction), but it makes the motive concrete and can enable further simplifications.
The transformation is implemented as \texttt{propagate\_motive\_once} in \texttt{theories/Transform/CaseCase.v}.

\subsection{Full normalization: driving under binders}

For supercompilation-style transformations, we need to normalize terms fully, not just to weak-head normal form.
This requires \emph{driving under binders}: reducing subterms even when they appear under \(\lambda\), \(\Pi\), or case motives.

\paragraph{Driving strategy.}
The supercompiler (see \texttt{theories/Transform/Supercompile.v}) uses a fuel-limited driving function that:
\begin{enumerate}
\item Applies head reductions (beta, fix unfolding, case-of-constructor)
\item Commutes nested cases (\textsc{CaseCase})
\item Propagates motives when scrutinees are known
\item Descends into subterms (including under binders)
\end{enumerate}

\paragraph{Eta-expansion.}
A key question for full normalization is whether we need eta-rules:
\[
\begin{array}{rcl}
\text{(eta-lambda)} & & \lambda x.\; (t\; x) \equiv t \quad\text{if } x \notin \mathit{FV}(t) \\
\text{(eta-case)} & & \Case{I}{t}{C}{\overline{\mathit{br}}} \equiv t \quad\text{if each } \mathit{br}_c = \Roll{I}{c}{\ldots}
\end{array}
\]

\textbf{Current status}: The implementation does \emph{not} require eta-rules for correctness.
Eta-expansion can be added as an optional normalization step if needed for canonical forms, but observational equivalence (CIU) is preserved without it.

\subsection{Unfolding and refolding of cycles}

Beyond term-level rewrites, cyclic proof objects admit transformations that restructure graph sharing and cycles:
\begin{itemize}
\item \textbf{Unfold}: expand a back-link or a shared subgraph, temporarily increasing size but exposing computation.
\item \textbf{Fold/refold}: identify repeated sub-derivations and introduce a back-link, or rearrange cycle boundaries (e.g. SCC-normal forms).
\end{itemize}

These transformations are the point where cyclicity pays off.
Because recursion is represented structurally (by cycles) rather than by a fixed syntactic operator, refolding can change \emph{which} cyclic structure represents a proof without changing what it proves.
The global progress condition is what makes this sound: it is the invariant that must be preserved or transported when cycles are restructured.
